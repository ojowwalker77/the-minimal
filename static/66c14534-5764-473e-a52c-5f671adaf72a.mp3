{
  "error": {
    "message": "[{'type': 'string_too_long', 'loc': ('body', 'input'), 'msg': 'String should have at most 4096 characters', 'input': 'Fine-tuning\\nLearn how to customize a model for your application.\\n\\nIntroduction\\nFine-tuning lets you get more out of the models available through the API by providing:\\n\\nHigher quality results than prompting\\nAbility to train on more examples than can fit in a prompt\\nToken savings due to shorter prompts\\nLower latency requests\\nOpenAI\\'s text generation models have been pre-trained on a vast amount of text. To use the models effectively, we include instructions and sometimes several examples in a prompt. Using demonstrations to show how to perform a task is often called \"few-shot learning.\"\\n\\nFine-tuning improves on few-shot learning by training on many more examples than can fit in the prompt, letting you achieve better results on a wide number of tasks. Once a model has been fine-tuned, you won\\'t need to provide as many examples in the prompt. This saves costs and enables lower-latency requests.\\n\\nAt a high level, fine-tuning involves the following steps:\\n\\nPrepare and upload training data\\nTrain a new fine-tuned model\\nEvaluate results and go back to step 1 if needed\\nUse your fine-tuned model\\nVisit our pricing page to learn more about how fine-tuned model training and usage are billed.\\n\\nWhich models can be fine-tuned?\\nFine-tuning is currently available for the following models:\\n\\n\\nYou can also fine-tune a fine-tuned model, which is useful if you acquire additional data and don\\'t want to repeat the previous training steps.\\n\\nWe expect gpt-4o-mini to be the right model for most users in terms of performance, cost, and ease of use.\\n\\nWhen to use fine-tuning\\nFine-tuning OpenAI text generation models can make them better for specific applications, but it requires a careful investment of time and effort. We recommend first attempting to get good results with prompt engineering, prompt chaining (breaking complex tasks into multiple prompts), and function calling, with the key reasons being:\\n\\nThere are many tasks at which our models may not initially appear to perform well, but results can be improved with the right prompts - thus fine-tuning may not be necessary\\nIterating over prompts and other tactics has a much faster feedback loop than iterating with fine-tuning, which requires creating datasets and running training jobs\\nIn cases where fine-tuning is still necessary, initial prompt engineering work is not wasted - we typically see best results when using a good prompt in the fine-tuning data (or combining prompt chaining / tool use with fine-tuning)\\nOur prompt engineering guide provides a background on some of the most effective strategies and tactics for getting better performance without fine-tuning. You may find it helpful to iterate quickly on prompts in our playground.\\n\\nCommon use cases\\nSome common use cases where fine-tuning can improve results:\\n\\nSetting the style, tone, format, or other qualitative aspects\\nImproving reliability at producing a desired output\\nCorrecting failures to follow complex prompts\\nHandling many edge cases in specific ways\\nPerforming a new skill or task that’s hard to articulate in a prompt\\nOne high-level way to think about these cases is when it’s easier to \"show, not tell\". In the sections to come, we will explore how to set up data for fine-tuning and various examples where fine-tuning improves the performance over the baseline model.\\n\\nAnother scenario where fine-tuning is effective is reducing cost and/or latency by replacing a more expensive model like gpt-4o with a fine-tuned gpt-4o-mini model. If you can achieve good results with gpt-4o, you can often reach similar quality with a fine-tuned gpt-4o-mini model by fine-tuning on the gpt-4o completions, possibly with a shortened instruction prompt.\\n\\nPreparing your dataset\\nOnce you have determined that fine-tuning is the right solution (i.e. you’ve optimized your prompt as far as it can take you and identified problems that the model still has), you’ll need to prepare data for training the model. You should create a diverse set of demonstration conversations that are similar to the conversations you will ask the model to respond to at inference time in production.\\n\\nEach example in the dataset should be a conversation in the same format as our Chat Completions API, specifically a list of messages where each message has a role, content, and optional name. At least some of the training examples should directly target cases where the prompted model is not behaving as desired, and the provided assistant messages in the data should be the ideal responses you want the model to provide.\\n\\n', 'ctx': {'max_length': 4096}}]",
    "type": "invalid_request_error",
    "param": null,
    "code": null
  }
}